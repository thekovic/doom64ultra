
#include <ultra64.h>
#include <PR/ramrom.h>	/* needed for argument passing into the app */
#include <os_internal.h>

#include "i_main.h"
#include "doomdef.h"
#include "st_main.h"
#include "config.h"

/*
 * Symbol genererated by "makerom" to indicate the end of the code segment
 * in virtual (and physical) memory
 */
extern char _codeSegmentEnd[];

/*
 * Symbols generated by "makerom" to tell us where the static segment is
 * in ROM.
 */

/*
 * Stacks for the threads as well as message queues for synchronization.
 */

extern u16 cfb[2][SCREEN_WD*SCREEN_HT]; // 8036A000
/* this stack size is in bytes */
#define	BOOT_STACKSIZE	0x100
u64	bootStack[BOOT_STACKSIZE/sizeof(u64)];

extern int globallump; // 800A68f8 r_local.h
extern int globalcm;   // 800A68fC r_local.h

//"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91"
//static char	sysmbols[] = {0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91};

//----------

#define SYS_THREAD_ID_IDLE 1
#define SYS_THREAD_ID_MAIN 2
#define SYS_THREAD_ID_TICKER 3
#define SYS_THREAD_ID_FAULT 4

OSThread	idle_thread;                        // 800A4A18

#define SYS_MAIN_STACKSIZE 0xA000
OSThread	main_thread;                        // 800A4BC8
u64	main_stack[SYS_MAIN_STACKSIZE/sizeof(u64)]; // 80099A00

#define SYS_TICKER_STACKSIZE 0x800
OSThread	sys_ticker_thread;                          // 800A4D78
u64	sys_ticker_stack[SYS_TICKER_STACKSIZE/sizeof(u64)]; // 800A3A00

#ifndef NDEBUG
#define SYS_FAULT_STACKSIZE 0x800
OSThread fault_thread;
u64	sys_fault_stack[SYS_FAULT_STACKSIZE/sizeof(u64)];
OSMesgQueue fault_queue;
OSMesg fault_msgbuf;
#endif

#define SYS_MSGBUF_SIZE_PI 128
OSMesgQueue msgque_Pi;                  // 800A4FA0
OSMesg msgbuf_Pi[SYS_MSGBUF_SIZE_PI];   // 800A4FD0

#define	SYS_FIFO_SIZE	512

#if __GNUC__ /* for GNU compiler */
u64 fifo_buff[2][SYS_FIFO_SIZE] __attribute__((aligned (16)));          /* buffer for RDP DL */      // 800633E0
u64 sys_rcp_stack[SP_DRAM_STACK_SIZE64] __attribute__((aligned (16)));  /* used for matrix stack */  // 800915E0
#else /* for SGI compiler */
u64 fifo_buff[2][SYS_FIFO_SIZE];            /* buffer for RDP DL */      // 800633E0
u64 sys_rcp_stack[SP_DRAM_STACK_SIZE64];    /* used for matrix stack */  // 800915E0
#endif

#define	SYS_YIELD_SIZE  OS_YIELD_DATA_SIZE
u64 gfx_yield_buff[SYS_YIELD_SIZE];     // 800919E0

OSTask vid_rsptask[2] = // 8005A590
{
    { .t = {
        M_GFXTASK,                          /* task type */
        NULL,                               /* task flags */
        (u64*) rspbootTextStart,            /* boot ucode pointer (fill in later) */
        0,                                  /* boot ucode size (fill in later) */
        (u64*) gspF3DEX2_NoN_fifoTextStart,  /* task ucode pointer (fill in later) */
        SP_UCODE_SIZE,                      /* task ucode size */
        (u64*) gspF3DEX2_NoN_fifoDataStart,  /* task ucode data pointer (fill in later) */
        SP_UCODE_DATA_SIZE,                 /* task ucode data size */
        &sys_rcp_stack[0],                  /* task dram stack pointer */
        SP_DRAM_STACK_SIZE8,                /* task dram stack size */
        &fifo_buff[0][0],                   /* task fifo buffer start ptr */
        &fifo_buff[0][0]+SYS_FIFO_SIZE,     /* task fifo buffer end ptr */
        NULL,                               /* task data pointer (fill in later) */
        0,                                  /* task data size (fill in later) */
        &gfx_yield_buff[0],                 /* task yield buffer ptr (not used here) */
        SYS_YIELD_SIZE                      /* task yield buffer size (not used here) */
    } },
    { .t = {
        M_GFXTASK,                          /* task type */
        NULL,                               /* task flags */
        (u64*) rspbootTextStart,            /* boot ucode pointer (fill in later) */
        0,                                  /* boot ucode size (fill in later) */
        (u64*) gspF3DEX2_NoN_fifoTextStart,  /* task ucode pointer (fill in later) */
        SP_UCODE_SIZE,                      /* task ucode size */
        (u64*) gspF3DEX2_NoN_fifoDataStart,  /* task ucode data pointer (fill in later) */
        SP_UCODE_DATA_SIZE,                 /* task ucode data size */
        &sys_rcp_stack[0],                  /* task dram stack pointer */
        SP_DRAM_STACK_SIZE8,                /* task dram stack size */
        &fifo_buff[1][0],                   /* task fifo buffer start ptr */
        &fifo_buff[1][0]+SYS_FIFO_SIZE,     /* task fifo buffer end ptr */
        NULL,                               /* task data pointer (fill in later) */
        0,                                  /* task data size (fill in later) */
        &gfx_yield_buff[0],                 /* task yield buffer ptr (not used here) */
        SYS_YIELD_SIZE                      /* task yield buffer size (not used here) */
    } }
};

Vp vid_viewport = // 8005A610
{ .vp = {
    {SCREEN_WD*2, SCREEN_HT*2, G_MAXZ,   0},		/* scale */
    {SCREEN_WD*2, SCREEN_HT*2,      0,   0},		/* translate */
} };

OSMesgQueue romcopy_msgque; // 800A4F70
OSMesg		romcopy_msgbuf; // 800A51D0

OSMesgQueue sys_msgque_joy; // 800A4F88
OSMesg		sys_msg_joy;    // 800A51D4

#define SYS_MSGBUF_SIZE_VID 16
OSMesgQueue sys_ticker_queue; // 800A4FB8
OSMesg		sys_ticker_msgbuf[SYS_MSGBUF_SIZE_VID]; // 800A51E0

#define SYS_MSGBUF_SIZE_VID2 2
OSMesgQueue rdp_done_queue; // 800A4F28
OSMesg		rdp_done_msgbuf[SYS_MSGBUF_SIZE_VID2]; // 800A51D8

OSMesgQueue vid_task_queue; // 800A4F40
OSMesg		vid_task_msgbuf[SYS_MSGBUF_SIZE_VID2]; // 800A5220

OSMesgQueue audio_task_queue; // 800A4F58
OSMesg		audio_task_msgbuf[SYS_MSGBUF_SIZE_VID2]; // 800A5228

OSContStatus gamepad_status[MAXCONTROLLERS]; // 800a5230
OSContPad   *gamepad_data;    // 800A5240

OSTask *vid_task;   // 800A5244
u32 vid_side;       // 800A5248

u32 video_hStart;   // 800A524c
u32 video_vStart1;  // 800A5250
u32 video_vStart2;  // 800A5254

u32 GfxIndex;       // 800A5258
u32 VtxIndex;       // 800A525C

u8 gamepad_bit_pattern; // 800A5260 // one bit for each controller

// Controller Pak
OSPfs ControllerPak;        // 800A5270
OSPfsState FileState[16];   // 800A52D8
s32 File_Num;   // 800A54D8
s32 Pak_Size;   // 800A54DC
u8 *Pak_Data;   // 800A54E0
s32 Pak_Memory; // 800A54E4

char Pak_Table[256] = // 8005A620
{
      '\0',// 0
      ' ', ' ', ' ', ' ', ' ',// 1
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 6
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',// 16
      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',// 26
      'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',// 36
      'u', 'v', 'w', 'x', 'y', 'z', '!', '"', '#','\'',// 46
      '*', '+', ',', '-', '.', '/', ':', '=', '?', '@',// 56
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 66
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 76
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 86
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 96
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 106
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 116
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 126
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 136
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 146
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 156
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 166
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 176
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 186
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 196
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 206
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 216
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 226
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',// 236
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' // 246
};

char Game_Name[16] = // 8005A790
{
    0x1D, 0x28, 0x28, 0x26, 0x0F, 0x16, 0x14, 0x0F, // (doom 64 ultra) byte index from Pak_Table
    0x2E, 0x25, 0x2D, 0x2B, 0x1A, 0x00, 0x00, 0x00
};

boolean disabledrawing = false; // 8005A720

s32 vsync = 0;              // 8005A724
s32 drawsync2 = 0;          // 8005A728
s32 drawsync1 = 0;          // 8005A72C
u32 NextFrameIdx = 0;       // 8005A730

s32 ControllerPakStatus = 1; // 8005A738
s32 gamepad_system_busy = 0; // 8005A73C
s32 FilesUsed = -1;                 // 8005A740
u32 SystemTickerStatus = 0;  // 8005a744

Gfx Gfx_base[2][MAX_GFX];    // 800653E0
Mtx Mtx_base[2][MAX_MTX];    // 800793E0
Vtx Vtx_base[2][MAX_VTX];    // 800795E0

Gfx *GFX1;	// 800A4A00
Gfx *GFX2;	// 800A4A04

Vtx *VTX1;	// 800A4A08
Vtx *VTX2;	// 800A4A0C

Mtx *MTX1;	// 800A4A10
Mtx *MTX2;	// 800A4A14

Gfx *GfxBlocks[8] = {0,0,0,0,0,0,0,0}; // 8005A748
Vtx *VtxBlocks[8] = {0,0,0,0,0,0,0,0}; // 8005A768

extern OSTask * wess_work(void);
#ifndef NDEBUG
void I_FaultThread(void *arg);
#endif

void I_Start(void)  // 80005620
{
    /* Re-initialize U64 operating system... */
    osInitialize();

    /* Create and start idle thread... */
    osCreateThread(&idle_thread, SYS_THREAD_ID_IDLE, I_IdleGameThread, (void *)0,
                   bootStack + BOOT_STACKSIZE/sizeof(u64), 10);
    osStartThread(&idle_thread);
}

void I_IdleGameThread(void *arg) // 8000567C
{
#ifndef NDEBUG
    osCreateMesgQueue(&fault_queue, &fault_msgbuf, 1);
    osCreateThread(&fault_thread, SYS_THREAD_ID_FAULT, I_FaultThread, (void *)0,
                   sys_fault_stack + SYS_FAULT_STACKSIZE/sizeof(u64), 10);
    osStartThread(&fault_thread);
#endif

    /* Create and start the Pi manager... */
    osCreatePiManager( (OSPri)OS_PRIORITY_PIMGR, &msgque_Pi, msgbuf_Pi,
                        SYS_MSGBUF_SIZE_PI );

    /* Create main thread... */
    osCreateThread(&main_thread, SYS_THREAD_ID_MAIN, D_DoomMain, (void *)0,
                   main_stack + SYS_MAIN_STACKSIZE/sizeof(u64), 10);
    osStartThread(&main_thread);

    osSetThreadPri(&idle_thread, (OSPri)OS_PRIORITY_IDLE);

    /* Idle loop... */
    do {
        osYieldThread();
    } while(TRUE);
}

#define STF_GFX_PENDING 1
#define STF_GFX_YIELDED 2
#define STF_GFX_RESUME 4
#define STF_RDP_PENDING 8
#define STF_RDP_DONE 16
#define STF_AUDIO_PENDING 32

void I_SystemTicker(void *arg) // 80005730
{
    int vbi_msg;
    int vidside;
    int side, ret;
    int current_fbuf, next_fbuf;
    OSTask *wess;
    OSTask *rspTask;
    OSTask *rspTaskPrev;

    //char str[64];

    vidside = 0;
    rspTask = NULL;
    rspTaskPrev = NULL;
    side = 1;

    while(true)
    {
        osRecvMesg(&sys_ticker_queue, (OSMesg *)&vbi_msg, OS_MESG_BLOCK);

        //sprintf(str, "SystemTickerStatus %d",SystemTickerStatus);
        //printstr(WHITE, 0, 13, str);
        //sprintf(str, "vbi_msg %d",vbi_msg);
        //printstr(WHITE, 0, 14, str);
        //sprintf(str, "vidside %d",vidside);
        //printstr(WHITE, 0, 15, str);

        switch (vbi_msg)
		{
		    case VID_MSG_RSP:				// end of signal processing
		        {
		            //sprintf(str, "VID_MSG_RSP");
                    //printstr(WHITE, 0, 28, str);

                    if(rspTask->t.type == M_AUDTASK)
                    {
                        SystemTickerStatus &= ~STF_AUDIO_PENDING;

                        if (SystemTickerStatus & STF_GFX_RESUME)
                        {
                            SystemTickerStatus &= ~STF_GFX_RESUME;
                            SystemTickerStatus |= STF_GFX_PENDING;

                            rspTask = rspTaskPrev;
                            osWritebackDCacheAll();
                            osSpTaskLoad(rspTask);
                            osSpTaskStartGo(rspTask);
                        }
                        else
                        {
                            if ((SystemTickerStatus & (STF_RDP_PENDING|STF_RDP_DONE)) == 0)
                            {
                                ret = osRecvMesg(&vid_task_queue, (OSMesg *)&vbi_msg, OS_MESG_NOBLOCK);
                                rspTask = (OSTask*)vbi_msg;

                                if(ret != -1)
                                {
                                    if(rspTask == vid_rsptask)
                                        vidside = 0;
                                    else
                                        vidside = 1;

                                    SystemTickerStatus |= STF_GFX_PENDING;

                                    osWritebackDCacheAll();
                                    osSpTaskLoad(rspTask);
                                    osSpTaskStartGo(rspTask);
                                }
                            }
                        }
                    }
                    else
                    {
                        SystemTickerStatus &= ~STF_GFX_PENDING;

                        if(SystemTickerStatus & STF_GFX_YIELDED)
                        {
                            SystemTickerStatus &= ~STF_GFX_YIELDED;

                            if (osSpTaskYielded(rspTask))
                            {
                                rspTaskPrev = rspTask;

                                SystemTickerStatus |= STF_GFX_RESUME;

                                osRecvMesg(&audio_task_queue, (OSMesg *)&vbi_msg, OS_MESG_NOBLOCK);
                                rspTask = (OSTask*)vbi_msg;

                                SystemTickerStatus |= STF_AUDIO_PENDING;

                                osWritebackDCacheAll();
                                osSpTaskLoad(rspTask);
                                osSpTaskStartGo(rspTask);
                            }
                        }
                        else
                        {
                            if ((SystemTickerStatus & STF_RDP_DONE) == 0)
                                SystemTickerStatus |= STF_RDP_PENDING;

                            ret = osRecvMesg(&audio_task_queue, (OSMesg *)&vbi_msg, OS_MESG_NOBLOCK);
                            rspTask = (OSTask*)vbi_msg;

                            if(ret!= -1)
                            {
                                SystemTickerStatus |= STF_AUDIO_PENDING;

                                osWritebackDCacheAll();
                                osSpTaskLoad(rspTask);
                                osSpTaskStartGo(rspTask);
                            }
                        }
                    }
		        }
				break;

            case VID_MSG_RDP:				// end of display processing
				{
				    //sprintf(str, "VID_MSG_RDP");
                    //printstr(WHITE, 0, 28, str);

				    SystemTickerStatus &= ~STF_RDP_PENDING;
				    SystemTickerStatus |= STF_RDP_DONE;

                    osViSwapBuffer(cfb[vidside]);
				}
				break;

            case VID_MSG_PRENMI:
                {
                    //sprintf(str, "VID_MSG_PRENMI");
                    //printstr(WHITE, 0, 28, str);
				    disabledrawing = true;
                    S_StopAll();
                    osViBlack(TRUE);
                    I_MoveDisplay(0,0);
                }
				break;

            case VID_MSG_VBI:
                {
                    //sprintf(str, "VID_MSG_VBI || vsync(%d) || side(%d)", vsync, side);
                    //printstr(WHITE, 0, 28, str);

                    vsync += 1;

                    if (audio_task_queue.validCount)
                    {
                        if (SystemTickerStatus & STF_GFX_PENDING)
                        {
                            SystemTickerStatus |= STF_GFX_YIELDED;
                            osSpTaskYield();
                        }
                        else
                        {
                            if ((SystemTickerStatus & STF_AUDIO_PENDING) == 0)
                            {
                                osRecvMesg(&audio_task_queue, (OSMesg *)&vbi_msg, OS_MESG_NOBLOCK);
                                rspTask = (OSTask*)vbi_msg;

                                SystemTickerStatus |= STF_AUDIO_PENDING;

                                osWritebackDCacheAll();
                                osSpTaskLoad(rspTask);
                                osSpTaskStartGo(rspTask);
                            }
                        }
                    }

                    if (side & 1)
                    {
                        if (gamepad_system_busy)
                        {
                            osContGetReadData(gamepad_data);
                            gamepad_system_busy = 0;
                        }

                        // next audio function task
                        wess = wess_work();
                        if (wess)
                            osSendMesg(&audio_task_queue,(OSMesg) wess, OS_MESG_NOBLOCK);
                    }
                    side++;

                    if (SystemTickerStatus & STF_RDP_DONE)
                    {
                        if ((u32)(vsync - drawsync2) < 2) continue;

                        current_fbuf = (int)osViGetCurrentFramebuffer();
                        next_fbuf = (int)osViGetNextFramebuffer();

                        if (next_fbuf != current_fbuf) continue;

                        SystemTickerStatus &= ~STF_RDP_DONE;

                        if (demoplayback || demorecording)
                        {
                            vsync = drawsync2 + 2;
                        }

                        //sprintf(str, "vsync %d | side %d",vsync, side);
                        //printstr(WHITE, 0, 29, str);

                        drawsync1 = vsync - drawsync2;
                        drawsync2 = vsync;

                        if ((ControllerPakStatus != 0) && (gamepad_system_busy == 0))
                        {
                            osContStartReadData(&sys_msgque_joy);
                            gamepad_system_busy = 1;
                        }

                        osSendMesg(&rdp_done_queue, (OSMesg)VID_MSG_KICKSTART, OS_MESG_NOBLOCK);
                    }

                    if(SystemTickerStatus == 0)
                    {
                        ret = osRecvMesg(&vid_task_queue, (OSMesg *)&vbi_msg, OS_MESG_NOBLOCK);
                        rspTask = (OSTask*)vbi_msg;

                        //sprintf(str, "ret %d", ret);
                        //printstr(WHITE, 0, 17, str);

                        if(ret != -1)
                        {
                            //sprintf(str, "rspTask->t.type %d",rspTask->t.type);
                            //printstr(WHITE, 0, 14, str);
                            //sprintf(str, "rspTask->t.type %x",(u64*)rspTask->t.ucode);
                            //printstr(WHITE, 0, 15, str);

                            if(rspTask == vid_rsptask)
                                vidside = 0;
                            else
                                vidside = 1;

                            SystemTickerStatus |= STF_GFX_PENDING;

                            osWritebackDCacheAll();
                            osSpTaskLoad(rspTask);
                            osSpTaskStartGo(rspTask);
                        }
                    }
                }
				break;
		}
    }
}

extern void S_Init(void);
extern void I_InitSram(void);

void I_Init(void) // 80005C50
{
    // assume NTSC
    OSViMode *ViMode = &osViModeTable[OS_VI_NTSC_LPN1];

    vid_rsptask[0].t.ucode_boot_size = (int)rspbootTextEnd - (int)rspbootTextStart;	// set ucode size (waste but who cares)
    vid_rsptask[1].t.ucode_boot_size = (int)rspbootTextEnd - (int)rspbootTextStart;	// set ucode size (waste but who cares)

    osCreateMesgQueue( &romcopy_msgque, &romcopy_msgbuf, 1 );

    osCreateMesgQueue( &sys_ticker_queue, sys_ticker_msgbuf, SYS_MSGBUF_SIZE_VID );

    osCreateMesgQueue(&rdp_done_queue, rdp_done_msgbuf, SYS_MSGBUF_SIZE_VID2);//&sys_msgque_jam, sys_msgbuf_jam
    osCreateMesgQueue(&vid_task_queue, vid_task_msgbuf, SYS_MSGBUF_SIZE_VID2);//&sys_msgque_ser, sys_msgbuf_ser
    osCreateMesgQueue(&audio_task_queue, audio_task_msgbuf, SYS_MSGBUF_SIZE_VID2);//&sys_msgque_tmr, sys_msgbuf_tmr

    if(osTvType == OS_TV_PAL)
    {
        ViMode = &osViModeTable[OS_VI_PAL_LPN1];
    }
    else if(osTvType == OS_TV_NTSC)
    {
        ViMode = &osViModeTable[OS_VI_NTSC_LPN1];
    }
    else if(osTvType == OS_TV_MPAL)
    {
        ViMode = &osViModeTable[OS_VI_MPAL_LPN1];
    }

    video_hStart = ViMode->comRegs.hStart;
    video_vStart1 = ViMode->fldRegs[0].vStart;
    video_vStart2 = ViMode->fldRegs[1].vStart;

    // Create and start the Vi manager and init the video mode...

	osCreateViManager( OS_PRIORITY_VIMGR );
    osViSetMode(ViMode);
    osViBlack(TRUE);

    osViSetSpecialFeatures(OS_VI_GAMMA_OFF|OS_VI_GAMMA_DITHER_OFF|OS_VI_DIVOT_OFF|OS_VI_DITHER_FILTER_OFF);

    osViSetXScale(1.0);
    osViSetYScale(1.0);

    D_memset(cfb, 0, ((SCREEN_WD*SCREEN_HT)*sizeof(u16))*2);
    osViSwapBuffer(cfb);

    if (osViGetCurrentFramebuffer() != cfb) {
		do {
		} while (osViGetCurrentFramebuffer() != cfb);
	}

    osViBlack(FALSE);

    osSetEventMesg( OS_EVENT_SP, &sys_ticker_queue, (OSMesg)VID_MSG_RSP );
    osSetEventMesg( OS_EVENT_DP, &sys_ticker_queue, (OSMesg)VID_MSG_RDP );
    osSetEventMesg( OS_EVENT_PRENMI, &sys_ticker_queue, (OSMesg)VID_MSG_PRENMI );

    osViSetEvent( &sys_ticker_queue, (OSMesg)VID_MSG_VBI, 1 ); // last parm: 2 indicates 30 FPS (1=60)

    vid_side = 1;

    /* Serial/Joy queue */

    osCreateMesgQueue(&sys_msgque_joy, &sys_msg_joy, 1);
    osSetEventMesg(OS_EVENT_SI, &sys_msgque_joy, &sys_msg_joy);

    osContInit(&sys_msgque_joy, &gamepad_bit_pattern, gamepad_status);

    I_InitSram();

    gamepad_data = (OSContPad *)bootStack;

    if ((gamepad_bit_pattern & 1) != 0)
    {
        osContStartReadData(&sys_msgque_joy);
        osRecvMesg(&sys_msgque_joy, NULL, OS_MESG_BLOCK);
        osContGetReadData(gamepad_data);
    }

    S_Init();

    /* Create and start ticker thread... */
    osCreateThread(&sys_ticker_thread, SYS_THREAD_ID_TICKER, I_SystemTicker, (void *)0,
                   sys_ticker_stack + SYS_TICKER_STACKSIZE/sizeof(u64), 11);
    osStartThread(&sys_ticker_thread);

    osJamMesg(&rdp_done_queue, (OSMesg)VID_MSG_KICKSTART, OS_MESG_NOBLOCK);
}

#include "stdarg.h"

void I_Error(char *error, ...) // 80005F30
{
    char buffer[256];
    va_list args;
    va_start (args, error);
    D_vsprintf (buffer, error, args);
    va_end (args);

    while (true)
    {
        I_ClearFrame();

        gDPPipeSync(GFX1++);
        gDPSetCycleType(GFX1++, G_CYC_FILL);
        gDPSetRenderMode(GFX1++,G_RM_NOOP,G_RM_NOOP2);
        gDPSetColorImage(GFX1++, G_IM_FMT_RGBA, G_IM_SIZ_16b, SCREEN_WD, OS_K0_TO_PHYSICAL(cfb[vid_side]));
        gDPSetFillColor(GFX1++, GPACK_RGBA5551(0,0,0,0) << 16 | GPACK_RGBA5551(0,0,0,0)) ;
        gDPFillRectangle(GFX1++, 0, 0, SCREEN_WD-1, SCREEN_HT-1);

        ST_Message(err_text_x, err_text_y, buffer, 0xffffffff);
        I_DrawFrame();
    }
}

typedef struct
{
	int pad_data;
} pad_t;

int I_GetControllerData(void) // 800060D0
{
    return ((pad_t*)gamepad_data)->pad_data;
}

void I_CheckGFX(void) // 800060E8
{
	memblock_t *block;

	Gfx **Gfx_Blocks;
	Vtx **Vtx_Blocks;

	int i, index;
	int block_idx;

	index = (int)((int)GFX1 - (int)GFX2) / sizeof(Gfx);

	if (index > MAX_GFX)
		I_Error("I_CheckGFX: GFX Overflow by %d\n",index);

	if ((index < (MAX_GFX-1024)) == 0)
	{
		Gfx_Blocks = GfxBlocks;
		block_idx = -1;

		for(i = 0; i < 8; i++)
		{
			block = (memblock_t *)((byte *)*Gfx_Blocks - sizeof(memblock_t));

			if (*Gfx_Blocks)
			{
				if(((u32)block->lockframe < NextFrameIdx - 1) == 0)
                {
                    Gfx_Blocks++;
                    continue;
                }

                block->lockframe = NextFrameIdx;
                GFX2 = (Gfx *)*Gfx_Blocks;
                goto move_gfx;
			}

            block_idx = i;
		}

		if (block_idx < 0)
			I_Error("I_CheckGFX: GFX Cache overflow");

		GFX2 = (Gfx *)Z_Malloc(MAX_GFX * sizeof(Gfx), PU_CACHE, &GfxBlocks[block_idx]);

	move_gfx:
		gSPBranchList(GFX1,GFX2);
		GFX1 = GFX2;
		GfxIndex += index;
	}

	index = (int)((int)VTX1 - (int)VTX2) / sizeof(Vtx);

	if (index > MAX_VTX)
		I_Error("I_CheckVTX: VTX Overflow by %d\n",index);

	if ((index < (MAX_VTX-615)) == 0)
	{
		Vtx_Blocks = VtxBlocks;
		block_idx = -1;

		for(i = 0; i < 8; i++)
		{
		    block = (memblock_t *)((byte *)*Vtx_Blocks - sizeof(memblock_t));

			if (*Vtx_Blocks)
			{
				if(((u32)block->lockframe < NextFrameIdx - 1) == 0)
                {
                    Vtx_Blocks++;
                    continue;
                }

                block->lockframe = NextFrameIdx;
                VTX2 = (Vtx *)*Vtx_Blocks;
                goto move_vtx;
			}

            block_idx = i;
		}

		if (block_idx < 0)
			I_Error("I_CheckGFX: VTX Cache overflow");

        VTX2 = (Vtx *)Z_Malloc(MAX_VTX * sizeof(Vtx), PU_CACHE, &VtxBlocks[block_idx]);

	move_vtx:
		VTX1 = VTX2;
		VtxIndex += index;
	}
}

void I_ClearFrame(void) // 8000637C
{
    NextFrameIdx += 1;

    GFX1 = Gfx_base[vid_side];
    GFX2 = GFX1;
    GfxIndex = 0;

    VTX1 = Vtx_base[vid_side];
    VTX2 = VTX1;
    VtxIndex = 0;

    MTX1 = Mtx_base[vid_side];

    vid_task = &vid_rsptask[vid_side];

    vid_task->t.ucode = (u64 *) gspF3DEX2_NoN_fifoTextStart;
    vid_task->t.ucode_data = (u64 *) gspF3DEX2_NoN_fifoDataStart;

    gMoveWd(GFX1++, G_MW_SEGMENT, G_MWO_SEGMENT_0, 0);

    gDPSetColorImage(GFX1++, G_IM_FMT_RGBA, G_IM_SIZ_16b, SCREEN_WD, OS_K0_TO_PHYSICAL(cfb[vid_side]));
    gDPSetScissor(GFX1++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WD, SCREEN_HT);

    gDPSetTextureFilter(GFX1++, G_TF_POINT);
    gDPSetColorDither(GFX1++, G_CD_DISABLE);

    gSPViewport(GFX1++, &vid_viewport);

    gSPClearGeometryMode(GFX1++, -1);
    gSPSetGeometryMode(GFX1++, G_SHADE|G_SHADING_SMOOTH|G_FOG );

    globallump = -1;
    globalcm = 0;
}

void I_DrawFrame(void)  // 80006570
{
    int index;

    gDPFullSync(GFX1++);
    gSPEndDisplayList(GFX1++);

    index = (int)((int)GFX1 - (int)GFX2) / sizeof(Gfx);
	if (index > MAX_GFX)
		I_Error("I_DrawFrame: GFX Overflow by %d\n\n",index);

    index = (int)((int)VTX1 - (int)VTX2) / sizeof(Vtx);
	if (index > MAX_VTX)
		I_Error("I_DrawFrame: VTX Overflow by %d\n",index);

    vid_task->t.data_ptr = (u64 *) Gfx_base[vid_side];
    vid_task->t.data_size = (u32)((((int)((int)GFX1 - (int)GFX2) / sizeof(Gfx)) + GfxIndex) * sizeof(Gfx));

    osSendMesg(&vid_task_queue,(OSMesg) vid_task, OS_MESG_NOBLOCK);
    osRecvMesg(&rdp_done_queue, NULL, OS_MESG_BLOCK);//retraceMessageQ
    vid_side ^= 1;
}

void I_GetScreenGrab(void) // 800066C0
{
    if ((SystemTickerStatus & ~STF_AUDIO_PENDING) || (vid_task_queue.validCount != 0)) {
        osRecvMesg(&rdp_done_queue, (OSMesg *)0, OS_MESG_BLOCK);
        osJamMesg(&rdp_done_queue, (OSMesg)VID_MSG_KICKSTART, OS_MESG_NOBLOCK);
    }
}

long LongSwap(long dat) // 80006724
{
    return (u32)dat >> 0x18 | (dat >> 8 & 0xff00U) | (dat & 0xff00U) << 8 | dat << 0x18;
}

short LittleShort(short dat) // 80006750
{
    return ((((dat << 8) | (dat >> 8 & 0xff)) << 16) >> 16);
}

short BigShort(short dat) // 80006770
{
    return ((dat << 8) | (dat >> 8 & 0xff)) & 0xffff;
}

void I_MoveDisplay(int x,int y) // 80006790
{
  int ViMode;

  ViMode = osViGetCurrentMode();

  osViModeTable[ViMode].comRegs.hStart =
       (int)(((int)video_hStart >> 0x10 & 65535) + x) % 65535 << 0x10 |
       (int)((video_hStart & 65535) + x) % 65535;

  osViModeTable[ViMode].fldRegs[0].vStart =
       (int)(((int)video_vStart1 >> 0x10 & 65535) + y) % 65535 << 0x10 |
       (int)((video_vStart1 & 65535) + y) % 65535;

  osViModeTable[ViMode].fldRegs[1].vStart =
       (int)(((int)video_vStart2 >> 0x10 & 65535) + y) % 65535 << 0x10 |
       (int)((video_vStart2 & 65535) + y) % 65535;
}

void I_WIPE_MeltScreen(void) // 80006964
{
    u16 *fb;
    int y1;
    int tpos;
    int yscroll;
    int height;

    fb = Z_Malloc((SCREEN_WD*SCREEN_HT)*sizeof(u16), PU_STATIC, NULL);

    I_GetScreenGrab();
    D_memcpy(&cfb[vid_side][0], &cfb[vid_side ^ 1][0], (SCREEN_WD*SCREEN_HT)*sizeof(u16));

    yscroll = 1;
    while( true )
    {
        y1 = 0;
        D_memcpy(fb, &cfb[vid_side ^ 1][0], (SCREEN_WD*SCREEN_HT)*sizeof(u16));

        I_ClearFrame();

        gDPSetCycleType(GFX1++, G_CYC_1CYCLE);
        gDPSetTextureLUT(GFX1++, G_TT_NONE);
        gDPSetTexturePersp(GFX1++, G_TP_NONE);
        gDPSetAlphaCompare(GFX1++, G_AC_THRESHOLD);
        gDPSetBlendColor(GFX1++, 0, 0, 0, 0);
        gDPSetCombineMode(GFX1++, G_CC_D64COMB19, G_CC_D64COMB19);
        gDPSetRenderMode(GFX1++, G_RM_XLU_SURF, G_RM_XLU_SURF2);
        gDPSetPrimColor(GFX1++, 0, 0, 15, 0, 0, 22); // 0x0f000016

        height = SCREEN_HT - (yscroll >> 2);
        tpos = 0;
        if (height > 0)
        {
            do
            {
                gDPSetTextureImage(GFX1++, G_IM_FMT_RGBA, G_IM_SIZ_16b , SCREEN_WD, fb);
                gDPSetTile(GFX1++, G_IM_FMT_RGBA, G_IM_SIZ_16b,
                           (SCREEN_WD >> 2), 0, G_TX_LOADTILE, 0, 0, 0, 0, 0, 0, 0);

                gDPLoadSync(GFX1++);
                gDPLoadTile(GFX1++, G_TX_LOADTILE,
                            (0 << 2), (tpos << 2),
                            ((SCREEN_WD-1) << 2), (((tpos+3)-1) << 2));

                gDPPipeSync(GFX1++);
                gDPSetTile(GFX1++, G_IM_FMT_RGBA, G_IM_SIZ_16b,
                           (SCREEN_WD >> 2), 0, G_TX_RENDERTILE, 0, 0, 0, 0, 0, 0, 0);

                gDPSetTileSize(GFX1++, G_TX_RENDERTILE,
                               (0 << 2), (tpos << 2),
                               ((SCREEN_WD-1) << 2), (((tpos+3)-1) << 2));

                gSPTextureRectangle(GFX1++,
                                    (0 << 2), (y1 << 2) + yscroll,
                                    (SCREEN_WD << 2), ((y1 + 3) << 2) + yscroll,
                                    G_TX_RENDERTILE,
                                    (0 << 5), (tpos << 5),
                                    (1 << 10), (1 << 10));

                y1 += 2;
                tpos += 2;
            } while (y1 < height);
        }

        yscroll += 2;
        if (yscroll >= 160) break;
        I_DrawFrame();
    }

    Z_Free(fb);
    I_WIPE_FadeOutScreen();
}

void I_WIPE_FadeOutScreen(void) // 80006D34
{
    u32 *fb;
    int y1, tpos, outcnt;

    fb = Z_Malloc((SCREEN_WD*SCREEN_HT)*sizeof(u32), PU_STATIC, NULL);

    I_GetScreenGrab();
    D_memcpy(fb, &cfb[vid_side ^ 1][0], (SCREEN_WD*SCREEN_HT)*sizeof(u16));

    outcnt = 248;
    do
    {
        I_ClearFrame();

        gDPSetCycleType(GFX1++, G_CYC_1CYCLE);
        gDPSetTextureLUT(GFX1++, G_TT_NONE);
        gDPSetTexturePersp(GFX1++, G_TP_NONE);
        gDPSetAlphaCompare(GFX1++, G_AC_NONE);
        gDPSetCombineMode(GFX1++, G_CC_D64COMB06, G_CC_D64COMB06);
        gDPSetRenderMode(GFX1++,G_RM_OPA_SURF,G_RM_OPA_SURF2);
        gDPSetPrimColor(GFX1++, 0, 0, outcnt, outcnt, outcnt, 0);

        tpos = 0;
        y1 = 0;
        do
        {
            gDPSetTextureImage(GFX1++, G_IM_FMT_RGBA, G_IM_SIZ_16b , SCREEN_WD, fb);
            gDPSetTile(GFX1++, G_IM_FMT_RGBA, G_IM_SIZ_16b,
                       (SCREEN_WD >> 2), 0, G_TX_LOADTILE, 0, 0, 0, 0, 0, 0, 0);

            gDPLoadSync(GFX1++);
            gDPLoadTile(GFX1++, G_TX_LOADTILE,
                        (0 << 2), (tpos << 2),
                        ((SCREEN_WD-1) << 2), (((tpos+3)-1) << 2));

            gDPPipeSync(GFX1++);
            gDPSetTile(GFX1++, G_IM_FMT_RGBA, G_IM_SIZ_16b,
                       (SCREEN_WD >> 2), 0, G_TX_RENDERTILE, 0, 0, 0, 0, 0, 0, 0);

            gDPSetTileSize(GFX1++, G_TX_RENDERTILE,
                           (0 << 2), (tpos << 2),
                           ((SCREEN_WD-1) << 2), (((tpos+3)-1) << 2));

            gSPTextureRectangle(GFX1++,
                                (0 << 2), (y1 << 2),
                                (SCREEN_WD << 2), ((y1+3) << 2),
                                G_TX_RENDERTILE,
                                (0 << 5), (tpos << 5),
                                (1 << 10), (1 << 10));

            tpos += 3;
            y1 += 3;
        } while (y1 != SCREEN_HT);

        I_DrawFrame();
        outcnt -= 8;
    } while (outcnt >= 0);

    I_GetScreenGrab();
    Z_Free(fb);
}


int I_CheckControllerPak(void) // 800070B0
{
    int ret, file;
    OSPfsState *fState;
    s32 MaxFiles [2];
    u8 validpaks;

    ControllerPakStatus = 0;

    if (gamepad_system_busy != 0)
    {
        do {
            osYieldThread();
        } while (gamepad_system_busy != 0);
    }

    FilesUsed = -1;
    ret = PFS_ERR_NOPACK;

    osPfsIsPlug(&sys_msgque_joy, &validpaks);

    /* does the current controller have a memory pak? */
    if (validpaks & 1)
    {
        ret = osPfsInit(&sys_msgque_joy, &ControllerPak, NULL);

        if ((ret != PFS_ERR_NOPACK) &&
            (ret != PFS_ERR_ID_FATAL) &&
            (ret != PFS_ERR_DEVICE) &&
            (ret != PFS_ERR_CONTRFAIL))
        {
            ret = osPfsNumFiles(&ControllerPak, MaxFiles, &FilesUsed);

            if (ret == PFS_ERR_INCONSISTENT)
                ret = osPfsChecker(&ControllerPak);

            if (ret == 0)
            {
                Pak_Memory = 123;
                fState = FileState;
                file = 0;
                do
                {
                    ret = osPfsFileState(&ControllerPak, file, fState);
                    file += 1;

                    if (ret != 0)
                      fState->file_size = 0;

                    Pak_Memory -= (fState->file_size >> 8);
                    fState += 1;
                } while (file != 16);
                ret = 0;
            }
        }
    }

    ControllerPakStatus = 1;

    return ret;
}

int I_DeletePakFile(int filenumb) // 80007224
{
    int ret;
    OSPfsState *fState;

    ControllerPakStatus = 0;

    if (gamepad_system_busy != 0)
    {
        do {
            osYieldThread();
        } while (gamepad_system_busy != 0);
    }

    fState = &FileState[filenumb];

    if (fState->file_size == 0) {
        ret = 0;
    }
    else
    {
        ret = osPfsDeleteFile(&ControllerPak,
            FileState[filenumb].company_code,
            FileState[filenumb].game_code,
            (u8*)FileState[filenumb].game_name,
            (u8*)FileState[filenumb].ext_name);

        if (ret == PFS_ERR_INCONSISTENT)
            ret = osPfsChecker(&ControllerPak);

        if (ret == 0)
        {
            Pak_Memory += (fState->file_size >> 8);
            fState->file_size = 0;
        }
    }

    ControllerPakStatus = 1;

    return ret;
}

int I_SavePakFile(int filenumb, int flag, byte *data, int size) // 80007308
{
    int ret;

    ControllerPakStatus = 0;

    if (gamepad_system_busy != 0)
    {
        do {
        osYieldThread();
        } while (gamepad_system_busy != 0);
    }

    ret = osPfsReadWriteFile(&ControllerPak, filenumb, (u8)flag, 0, size, (u8*)data);

    if (ret == PFS_ERR_INCONSISTENT)
        ret = osPfsChecker(&ControllerPak);

    ControllerPakStatus = 1;

    return ret;
}

#define COMPANY_CODE 0x3544     // 5D
#define GAME_CODE 0x4e454441    // NEDA

int I_ReadPakFile(void) // 800073B8
{
    int ret;
    u8 *ext_name;

    ControllerPakStatus = 0;

    if (gamepad_system_busy != 0)
    {
        do {
        osYieldThread();
        } while (gamepad_system_busy != 0);
    }

    Pak_Data = NULL;
    Pak_Size = 0;
    ext_name = NULL;

    ret = osPfsFindFile(&ControllerPak, COMPANY_CODE, GAME_CODE, (u8*)Game_Name, ext_name, &File_Num);

    if (ret == 0)
    {
        Pak_Size = FileState[File_Num].file_size;
        Pak_Data = (byte *)Z_Malloc(Pak_Size, PU_STATIC, NULL);
        ret = osPfsReadWriteFile(&ControllerPak, File_Num, PFS_READ, 0, Pak_Size, Pak_Data);
    }

    ControllerPakStatus = 1;

    return ret;
}

int I_CreatePakFile(void) // 800074D4
{
    int ret;
    u8 ExtName [8];

    ControllerPakStatus = 0;

    if (gamepad_system_busy != 0)
    {
        do {
          osYieldThread();
        } while (gamepad_system_busy != 0);
    }

    if (Pak_Memory < 2)
        Pak_Size = 256;
    else
        Pak_Size = 512;

    Pak_Data = (byte *)Z_Malloc(Pak_Size, PU_STATIC, NULL);
    D_memset(Pak_Data, 0, Pak_Size);

    *(int*)ExtName = 0;

    ret = osPfsAllocateFile(&ControllerPak, COMPANY_CODE, GAME_CODE, (u8*)Game_Name, ExtName, Pak_Size, &File_Num);

    if (ret == PFS_ERR_INCONSISTENT)
        ret = osPfsChecker(&ControllerPak);

    if (ret == 0)
        ret = osPfsReadWriteFile(&ControllerPak, File_Num, PFS_WRITE, 0, Pak_Size, Pak_Data);

    ControllerPakStatus = 1;

    return ret;
}

#ifndef NDEBUG

typedef struct {
  u32 mask;
  u32 value;
  char* string;
} regDesc_t;

static regDesc_t causeDesc[] = {
    {CAUSE_BD, CAUSE_BD, "BD"},
    {CAUSE_IP8, CAUSE_IP8, "IP8"},
    {CAUSE_IP7, CAUSE_IP7, "IP7"},
    {CAUSE_IP6, CAUSE_IP6, "IP6"},
    {CAUSE_IP5, CAUSE_IP5, "IP5"},
    {CAUSE_IP4, CAUSE_IP4, "IP4"},
    {CAUSE_IP3, CAUSE_IP3, "IP3"},
    {CAUSE_SW2, CAUSE_SW2, "IP2"},
    {CAUSE_SW1, CAUSE_SW1, "IP1"},
    {CAUSE_EXCMASK, EXC_INT, "Interrupt"},
    {CAUSE_EXCMASK, EXC_MOD, "TLB modification exception"},
    {CAUSE_EXCMASK, EXC_RMISS, "TLB exception on load or instruction fetch"},
    {CAUSE_EXCMASK, EXC_WMISS, "TLB exception on store"},
    {CAUSE_EXCMASK, EXC_RADE, "Address error on load or instruction fetch"},
    {CAUSE_EXCMASK, EXC_WADE, "Address error on store"},
    {CAUSE_EXCMASK, EXC_IBE, "Bus error exception on instruction fetch"},
    {CAUSE_EXCMASK, EXC_DBE, "Bus error exception on data reference"},
    {CAUSE_EXCMASK, EXC_SYSCALL, "System call exception"},
    {CAUSE_EXCMASK, EXC_BREAK, "Breakpoint exception"},
    {CAUSE_EXCMASK, EXC_II, "Reserved instruction exception"},
    {CAUSE_EXCMASK, EXC_CPU, "Coprocessor unusable exception"},
    {CAUSE_EXCMASK, EXC_OV, "Arithmetic overflow exception"},
    {CAUSE_EXCMASK, EXC_TRAP, "Trap exception"},
    {CAUSE_EXCMASK, EXC_VCEI,
     "Virtual coherency exception on intruction fetch"},
    {CAUSE_EXCMASK, EXC_FPE, "Floating point exception (see fpcsr)"},
    {CAUSE_EXCMASK, EXC_WATCH, "Watchpoint exception"},
    {CAUSE_EXCMASK, EXC_VCED, "Virtual coherency exception on data reference"},
    {0, 0, ""}};

static regDesc_t srDesc[] = {{SR_CU3, SR_CU3, "CU3"},
                             {SR_CU2, SR_CU2, "CU2"},
                             {SR_CU1, SR_CU1, "CU1"},
                             {SR_CU0, SR_CU0, "CU0"},
                             {SR_RP, SR_RP, "RP"},
                             {SR_FR, SR_FR, "FR"},
                             {SR_RE, SR_RE, "RE"},
                             {SR_BEV, SR_BEV, "BEV"},
                             {SR_TS, SR_TS, "TS"},
                             {SR_SR, SR_SR, "SR"},
                             {SR_CH, SR_CH, "CH"},
                             {SR_CE, SR_CE, "CE"},
                             {SR_DE, SR_DE, "DE"},
                             {SR_IBIT8, SR_IBIT8, "IM8"},
                             {SR_IBIT7, SR_IBIT7, "IM7"},
                             {SR_IBIT6, SR_IBIT6, "IM6"},
                             {SR_IBIT5, SR_IBIT5, "IM5"},
                             {SR_IBIT4, SR_IBIT4, "IM4"},
                             {SR_IBIT3, SR_IBIT3, "IM3"},
                             {SR_IBIT2, SR_IBIT2, "IM2"},
                             {SR_IBIT1, SR_IBIT1, "IM1"},
                             {SR_KX, SR_KX, "KX"},
                             {SR_SX, SR_SX, "SX"},
                             {SR_UX, SR_UX, "UX"},
                             {SR_KSU_MASK, SR_KSU_USR, "USR"},
                             {SR_KSU_MASK, SR_KSU_SUP, "SUP"},
                             {SR_KSU_MASK, SR_KSU_KER, "KER"},
                             {SR_ERL, SR_ERL, "ERL"},
                             {SR_EXL, SR_EXL, "EXL"},
                             {SR_IE, SR_IE, "IE"},
                             {0, 0, ""}};

static regDesc_t fpcsrDesc[] = {{FPCSR_FS, FPCSR_FS, "FS"},
                                {FPCSR_C, FPCSR_C, "C"},
                                {FPCSR_CE, FPCSR_CE, "Unimplemented operation"},
                                {FPCSR_CV, FPCSR_CV, "Invalid operation"},
                                {FPCSR_CZ, FPCSR_CZ, "Division by zero"},
                                {FPCSR_CO, FPCSR_CO, "Overflow"},
                                {FPCSR_CU, FPCSR_CU, "Underflow"},
                                {FPCSR_CI, FPCSR_CI, "Inexact operation"},
                                {FPCSR_EV, FPCSR_EV, "EV"},
                                {FPCSR_EZ, FPCSR_EZ, "EZ"},
                                {FPCSR_EO, FPCSR_EO, "EO"},
                                {FPCSR_EU, FPCSR_EU, "EU"},
                                {FPCSR_EI, FPCSR_EI, "EI"},
                                {FPCSR_FV, FPCSR_FV, "FV"},
                                {FPCSR_FZ, FPCSR_FZ, "FZ"},
                                {FPCSR_FO, FPCSR_FO, "FO"},
                                {FPCSR_FU, FPCSR_FU, "FU"},
                                {FPCSR_FI, FPCSR_FI, "FI"},
                                {FPCSR_RM_MASK, FPCSR_RM_RN, "RN"},
                                {FPCSR_RM_MASK, FPCSR_RM_RZ, "RZ"},
                                {FPCSR_RM_MASK, FPCSR_RM_RP, "RP"},
                                {FPCSR_RM_MASK, FPCSR_RM_RM, "RM"},
                                {0, 0, ""}};

static char *faultbuf;

__attribute__ ((format (printf, 1, 2)))
static void I_FaultPrintf(const char *text, ...)
{
    va_list args;
    va_start (args, text);
    int ret = D_vsprintf (faultbuf, text, args);
    if (ret > 0)
        faultbuf += ret;
    va_end (args);
}

static void I_FaultPrintRegister(u32 regValue, char* regName, regDesc_t* regDesc) {
    int first = 1;

    I_FaultPrintf("%s\t\t0x%08lx\n <", regName, regValue);
    while (regDesc->mask != 0) {
        if ((regValue & regDesc->mask) == regDesc->value) {
            if (first)
                first = 0;
            else
                I_FaultPrintf(",");
            I_FaultPrintf("%s", regDesc->string);
        }
        regDesc++;
    }
    I_FaultPrintf(">\n");
}

#define MAX_STACK_TRACE 100

static void* stackTraceReturnAddresses[MAX_STACK_TRACE];

int I_GetPrevStackPointer(void** prev_sp, void** prev_ra, void* sp, void* ra)
{
    unsigned* wra = (unsigned*)ra;
    unsigned* k0base = (unsigned*)K0BASE;
    int spofft;

    if (wra < k0base) {
        return 0;
    }
    /* scan towards the beginning of the function -
       addui sp,sp,spofft should be the first command */
    while ((*wra >> 16) != 0x27bd) {
        /* test for "scanned too much" */
        if (wra < k0base) {
            return 0;
        }
        wra--;
    }
    spofft = ((int)*wra << 16) >> 16; /* sign-extend */
    *prev_sp = (char*)sp - spofft;
    /* now scan forward for sw r31,raofft(sp) */
    while (wra < (unsigned*)ra) {
        if ((*wra >> 16) == 0xafbf) {
            int raofft = ((int)*wra << 16) >> 16; /* sign */
            *prev_ra = *(void**)((char*)sp + raofft);
            return 1;
        }
        wra++;
    }
    return 0; /* failed to find where ra is saved */
}

int I_GetCallStack(u64 sp_val, u64 ra_val) {
    void* sp = (void*)(u32)sp_val; /* stack pointer from thread state */
    void* ra = (void*)(u32)ra_val; /* return address from thread state */
    int i = 0;

    while (i < MAX_STACK_TRACE &&
            I_GetPrevStackPointer(&sp, &ra, sp, ra) && ra != 0) {
        stackTraceReturnAddresses[i++] = ra;
    }
    return i; /* stack size */
}

void I_FaultThread(void *arg)
{
    OSMesg msg = 0;
    OSIntMask mask;
    static OSThread *curr;
    char buf[1500];

    buf[0] = 0;
    osSetEventMesg(OS_EVENT_FAULT, &fault_queue, NULL);

    do {
        osRecvMesg(&fault_queue, &msg, OS_MESG_BLOCK);
        if (msg != NULL)
            continue;
        mask = osSetIntMask(1);
        curr = __osGetCurrFaultedThread();
        osSetIntMask(mask);

        if (curr)
        {
            faultbuf = buf;
            __OSThreadContext* tc = &curr->context;

            I_FaultPrintRegister(tc->cause, "cause", causeDesc);
            I_FaultPrintRegister(tc->sr, "sr", srDesc);
            I_FaultPrintf("badvaddr\t0x%08lx\n\n", tc->badvaddr);
            I_FaultPrintRegister(tc->fpcsr, "fpcsr", fpcsrDesc);
            int stackTraceSize = I_GetCallStack(tc->sp, tc->ra);
            I_FaultPrintf("stacktrace:\n");
            I_FaultPrintf("%08lx\n", (u32)(tc->pc));
            I_FaultPrintf("%08lx\n", (u32)(tc->ra));
            for (int i = 0; i < stackTraceSize; ++i) {
                I_FaultPrintf("%08lx\n", (u32)stackTraceReturnAddresses[i]);
            }
            buf[ARRAYLEN(buf)-1] = 0;
            I_Error("Fault in thread %ld\n%s", curr->id, buf);
        }
    } while(TRUE);
}
#endif
